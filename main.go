package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

//Return values
const (
	FileReadError = 0
	NormalFiles   = 1
	CompilerFlags = 2
	AutoGenerated = 3
)

type Applier interface {
	CheckHeader(target *os.File, t *TagContext) (bool, error)
	ApplyHeader(path string, t *TagContext) error
}

type TagContext struct {
	sourceExt     string
	excludeList   []string
	templatePath  string
	templateFiles TemplateFiles
	dryRun        bool
	outfileList   []string
}

//TemplateFiles stores template of header
type TemplateFiles struct {
	goTemplateFile *os.File
	shTemplateFile *os.File
	dTemplateFile  *os.File
	mTemplateFile  *os.File
}

func main() {
	ppath := flag.String("path", ".", "project path")
	srcExt := flag.String("ext", ".go", "file extention for tagging")
	excludes := flag.String("excludes", "vendor", "exclude folders")
	tpath := flag.String("t", "./template", "template files path")
	dryRun := flag.Bool("d", false, "dry run")
	verbose := flag.Bool("v", false, "verbose output")
	flag.Parse()

	//Check for kind of templates available.
	//Dockerfile? shell script? golang? Makefile?
	dTemplateFile := filepath.Join(*tpath, "dockerfile.txt")
	dTFile, err := os.OpenFile(dTemplateFile, os.O_RDONLY, 0666)
	if err != nil {
		fmt.Println("No template file for Dockerfile", dTemplateFile)
	}
	if dTFile != nil {
		defer dTFile.Close()
	}

	goTemplateFile := filepath.Join(*tpath, "go.txt")
	goTFile, err := os.OpenFile(goTemplateFile, os.O_RDONLY, 0666)
	if err != nil {
		fmt.Println("No template file for golang files")
	}
	if goTFile != nil {
		defer goTFile.Close()
	}

	bashTemplateFile := filepath.Join(*tpath, "bash.txt")
	bashTFile, err := os.OpenFile(bashTemplateFile, os.O_RDONLY, 0666)
	if err != nil {
		fmt.Println("No template file for bash scripts")
	}
	if bashTFile != nil {
		defer bashTFile.Close()
	}

	makeTemplateFile := filepath.Join(*tpath, "makefile.txt")
	makeTFile, err := os.OpenFile(makeTemplateFile, os.O_RDONLY, 0666)
	if err != nil {
		fmt.Println("No template file for Makefile")
	}
	if makeTFile != nil {
		defer makeTFile.Close()
	}

	excludeList := strings.Split(*excludes, " ")

	templateFiles := TemplateFiles{mTemplateFile: makeTFile, shTemplateFile: bashTFile, goTemplateFile: goTFile, dTemplateFile: dTFile}

	t := TagContext{sourceExt: *srcExt, excludeList: excludeList, templateFiles: templateFiles, templatePath: *tpath, dryRun: *dryRun}

	//TODO:
	// itterate to all template file handlers, if not nill defer Close.

	err = filepath.Walk(*ppath, t.tagFiles)
	if err != nil {
		panic(err)
	}

	if !*dryRun {
		fmt.Println("Files modified : ", len(t.outfileList))
	} else {
		fmt.Println("Files missing header : ", len(t.outfileList))
	}
	if *verbose {
		for _, path := range t.outfileList {
			fmt.Println(path)
		}
	}
}

func (t *TagContext) tagFiles(path string, f os.FileInfo, err error) error {

	var applier Applier
	processed := false

	if (f.Name() == ".git" || f.Name() == ".svn" || f.Name() == "..") && f.IsDir() {
		return filepath.SkipDir
	}

	if f.IsDir() {
		for _, exclude := range t.excludeList {
			if f.Name() == exclude {
				return filepath.SkipDir
			}
		}
	}

	if !f.IsDir() && f.Size() > 0 { //&& filepath.Ext(f.Name()) == t.sourceExt

		file, err := os.OpenFile(path, os.O_RDONLY, 0666)
		if err != nil {
			return err
		}
		defer file.Close()

		fname := strings.Split(f.Name(), ".")
		if len(fname) == 1 {
			if fname[0] == "Makefile" {
				applier = &makefileApplier{}
				processed = true
			} else if fname[0] == "Dockerfile" {
				applier = &dockerfileApplier{}
				processed = true
			} else { // No extention.
				applier = &bashApplier{}
				processed = true
			}
		} else { // Check extenstions apart from makefile.

			if fname[0] == "Makefile" {
				applier = &makefileApplier{}
				processed = true
			}
			if fname[1] == "go" {
				applier = &golangApplier{}
				processed = true
			}
			if strings.ToLower(fname[1]) == "dockerfile" {
				applier = &dockerfileApplier{}
				processed = true
			}
			if fname[1] == "sh" {
				applier = &bashApplier{}
				processed = true
			}
		}
		if !processed {
			return nil
		}
		processed = false
		headerExist, err := applier.CheckHeader(file, t)
		if err != nil {
			return err
		}
		if headerExist {
			return nil
		}

		err = applier.ApplyHeader(path, t)
		if err != nil {
			return err
		}

		t.outfileList = append(t.outfileList, path)
	}
	return nil
}
