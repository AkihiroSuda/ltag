package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

//Return values
const (
	FileReadError = 0
	NormalFiles   = 1
	CompilerFlags = 2
	AutoGenerated = 3
)

type TagContext struct {
	sourceExt    string
	excludeList  []string
	templatePath string
	templateFile *os.File
	dryRun       bool
	outfileList  []string
}

func main() {
	ppath := flag.String("path", ".", "project path")
	srcExt := flag.String("ext", ".go", "file extention for tagging")
	excludes := flag.String("excludes", "vendor", "exclude folders")
	tpath := flag.String("t", "", "template file path")
	dryRun := flag.Bool("d", false, "dry run")
	verbose := flag.Bool("v", false, "verbose output")
	flag.Parse()

	if *tpath == "" {
		fmt.Println("template path missing")
		flag.Usage()
		return
	}

	excludeList := strings.Split(*excludes, " ")

	tfile, err := os.OpenFile(*tpath, os.O_RDONLY, 0666)
	if err != nil {
		panic(err)
	}
	defer tfile.Close()

	t := TagContext{sourceExt: *srcExt, excludeList: excludeList, templatePath: *tpath, templateFile: tfile, dryRun: *dryRun}

	err = filepath.Walk(*ppath, t.tagFiles)
	if err != nil {
		panic(err)
	}

	if !*dryRun {
		fmt.Println("Files modified : ", len(t.outfileList))
	} else {
		fmt.Println("Files missing header : ", len(t.outfileList))
	}
	if *verbose {
		for _, path := range t.outfileList {
			fmt.Println(path)
		}
	}
}

func (t *TagContext) tagFiles(path string, f os.FileInfo, err error) error {
	if (f.Name() == ".git" || f.Name() == ".svn" || f.Name() == "..") && f.IsDir() {
		return filepath.SkipDir
	}

	for _, exclude := range t.excludeList {
		if f.Name() == exclude {
			return filepath.SkipDir
		}
	}

	if !f.IsDir() && filepath.Ext(f.Name()) == t.sourceExt && f.Size() > 0 {

		file, err := os.OpenFile(path, os.O_RDONLY, 0666)
		if err != nil {
			return err
		}
		defer file.Close()
		t.templateFile.Seek(0, 0)

		headerExist, err := t.checkTemplateHeader(file)
		if err != nil {
			return err
		}

		if headerExist {
			return nil
		}

		if t.dryRun {
			t.outfileList = append(t.outfileList, path)
			return nil
		}

		//Reset the read pointers to begining of file.
		t.templateFile.Seek(0, 0)
		file.Seek(0, 0)

		sFlags, flags, err := t.checkSpecialConditions(file)
		if err != nil {
			return err
		}
		file.Seek(0, 0)

		tempFile := path + ".tmp"
		tFile, err := os.OpenFile(tempFile, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0666)
		if err != nil {
			return err
		}
		defer tFile.Close()

		reader := bufio.NewReader(file)
		if sFlags == CompilerFlags {
			tFile.Write(flags)
			tFile.Write([]byte("\n\n"))
			_, _, err = reader.ReadLine()
			_, _, err = reader.ReadLine()
		}

		if sFlags == AutoGenerated {
			//This should not hit.
			panic(err)
		}

		_, err = io.Copy(tFile, t.templateFile)
		if err != nil {
			return err
		}

		_, err = io.Copy(tFile, reader)
		if err != nil {
			return err
		}

		err = os.Rename(tempFile, path)
		if err != nil {
			return err
		}

		t.outfileList = append(t.outfileList, path)
	}
	return nil
}

func (t *TagContext) checkTemplateHeader(target *os.File) (bool, error) {
	//Check compiler flags.
	cFlags, cbuf, err := t.checkSpecialConditions(target)
	if err != nil {
		return false, err
	}
	target.Seek(0, 0)

	tbuf, err := ioutil.ReadFile(t.templatePath)
	if err != nil {
		return false, err
	}

	if cFlags == AutoGenerated {
		return true, nil
	}

	var templateBuf string
	if cFlags == CompilerFlags {
		templateBuf = fmt.Sprintf("%s%s%s", cbuf, "\n\n", tbuf)
	} else {
		templateBuf = string(tbuf)
	}

	targetBuf := make([]byte, len(templateBuf))

	n, err := target.Read(targetBuf)
	if err != nil {
		return false, err
	}

	if n == len(templateBuf) {
		if strings.Compare(string(templateBuf), string(targetBuf)) == 0 {
			return true, nil
		}
	}

	return false, nil
}

// Checks for
// - golang compiler flags
// - autogenerated files
func (t *TagContext) checkSpecialConditions(target *os.File) (uint8, []byte, error) {

	reader := bufio.NewReader(target)
	buf, _, err := reader.ReadLine()
	if err != nil {
		return NormalFiles, nil, err
	}

	// checks for Package comments as per https://blog.golang.org/godoc-documenting-go-code
	if strings.HasPrefix(string(buf), "//") &&
		(strings.Contains(string(buf), "build") ||
			strings.Contains(string(buf), "unix") ||
			strings.Contains(string(buf), "linux") ||
			strings.Contains(string(buf), "windows") ||
			strings.Contains(string(buf), "darwin") ||
			strings.Contains(string(buf), "freebsd")) &&
		!strings.Contains(string(buf), "Package") {
		return CompilerFlags, buf, nil
	}
	if strings.HasPrefix(string(buf), "//") &&
		(strings.Contains(string(buf), "DO NOT EDIT")) {
		return AutoGenerated, nil, nil
	}
	return NormalFiles, nil, nil
}
